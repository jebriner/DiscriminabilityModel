rm(list=ls(all=T))switch(menu(c("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPress 1 and then Return. Then open the file of coneoutputs you want to generate\ncontrasts for.  For those following the demonstration, open the file\nconeoutput.dem in Colour processing.")), Outputfilepath<-file.choose())# A menu of one selection (1), which enables you to find the file of cone outputs # you want to standardise.file.test <- TRUEsetwd(dirname(Outputfilepath))# Sets the working directory to the directory of the cone output file.while (file.test){	cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease enter a name for the output file, then press Return.  For those people\nfollowing the demonstration I suggest using the file name contrasts.dem.\n", file="")Contrastsfilepath<-c(paste(dirname(Outputfilepath), .Platform$file.sep, fnam<-scan(n=1, what="character", quiet=1), sep=""))# Creates a file path (the parent directory of the data folder), a file path# separator,  and a file name of your choice.	if(file.exists(fnam)) {		cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA file by this name already exists, please select a number.\n", file="")switch(menu(c("Rename file.", "Over write the current file.")), file.test<-TRUE, file.test<-FALSE)}	else {file.test <- FALSE}}# If this file already exists then there is the option of overwriting or renaming # the file. If you rename file.test goes to TRUE and is fed back into the loop. # If the file name does not already exist or you choose to overwrite file.test # goes to FALSE and you exit the loop.cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\Do you want to compare all reflectance spectra to each other or do you want to compare specific spectra with each other.\n", file="")switch(menu(c("All", "Specific")), allorsome<-c("ALL"), allorsome<-("SOME"))# Enables you to select which mode to run in,  All makes comparisons between # all spectra, Specific, comparisons between all spectra and a specified # reference.if(allorsome=="SOME"){cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease enter the experiment names of those birds with which you want to use as\nstandards. For those people following the demonstration enter the experiment\nnames K983388 (Return) and then N863616 (Double Return).\n", file="")Averagebirds<-c(scan(what="character", quiet=1))# Creates a character vector of Experiment names.cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease enter the number of patches measured per bird, then press Return. For those\npeople follwing the demonstration, enter 5.\n", file="")Patcherer<-c(scan(n=1, what="character", quiet=1))# Creates a vector of the number of patches.Patches<-c(letters[1:as.numeric(Patcherer)])# Creates a vector of the alphabet the same length as the number of patches.cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlease enter the number of measurments made per patch, then press Return.  For\nthose people following the demonstration, enter 3.\n", file="")numberperpatch<-as.numeric((scan(n=1, what="character", quiet=1)))}# Creates a vector of the number of measurements made per patch.coneoutput<-data.frame(read.csv(Outputfilepath, sep=",", skip=7))attach(coneoutput)# Opens and attaches the cone output data frame.heads<-data.frame(read.csv(Outputfilepath, sep=","))attach(heads)# Opens and attaches the cone output file header.heady<-heads[1:6,]cat(file=Contrastsfilepath, "a", ",", "b", ",", "c", ",", "d", ",", "e",  "\n", append=FALSE, sep ="")for(roww in 1:6){cat(file=Contrastsfilepath, as.character((heads[roww,][1])$a),  ",", as.character((heads[roww,][2])$b), ",", as.character((heads[roww,][3])$c), ",", as.character((heads[roww,][4])$d), ",", as.character((heads[roww,][5])$e), "\n", append=TRUE, sep ="")}# Writes the file header to the header of the new output file.channels<-(length(names(coneoutput))-2)# Determines the chromacy of the visual system.VKT<-as.character(heads[,2][5])# Determines whether the cone outputs are von Kreis transformed or not.alpha<-c()cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat do you want to set alpha as\n", file="")switch(menu(c("High light intensity (T=10,000)", "Low Light intenisty (T=500)", "Specify alpha")), alpha<-rep(10000, channels), alpha<-rep(500, channels), alpha<-scan(nmax=1, what="character", quiet=1))alpha<-as.numeric(as.character(alpha))WFP<-rep(0, channels)# Vector of weber fractions for each cone, default = 0 , so that noise due # to weber's law is equal to 0. cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhich Weber fractions do you want to use.\n", file="")switch(menu(c("All cones = 0.05", "Ignore (i.e. set to 0)","Own data")), WFP<-c(rep(0.05, channels)), WFP<-c(rep(0, channels)), WFP<-scan(nmax=channels, what="character", quiet=1))WFP<-as.numeric(as.character(WFP))# Allows user defined weber fractions, or weber fractions taken from the # Pekin Robin, to be used  RDP<-rep(1, channels)	cat("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhich cone density ratios do you whish to use for calculating receptor noise.\n", file="")switch(menu(c("Blue Tit Data", "Ignore (i.e. set to 1)", "Own data")), RDP<-c(0.371, 0.711, 0.993, 1), RDP<-c(rep(1, channels)), RDP<-scan(nmax=channels, what="character", quiet=1))# Allows user defined receptor densities, or densities taken from the # Blue tit, to be used  NoiseBT<-c()# Empty vector which will contain noise levels for each cone typenoisef<-function(flux, weber, density){ dereislaw<-1/(as.numeric(as.character(flux))^2)weberlaw<-as.numeric(as.character(weber))^2sampling<-as.numeric(as.character(density))((dereislaw+weberlaw)/sampling)^0.5}#  A function which takes the a parameter from QFP, WFP, RDP and # calculates noiseprodrows<-function(x, data){prod(data[x,])}# A function which calculates the product of a matrix rowdenom<-function(x, y){(prod(y[c(1:channels)[-x]]))^2}# A function which gets the product of noise from all cones except the# specified cone. otherchan<-function(x){inopponent<-duplicated(c(lowertriind[x,], c(1:channels)))[3:(channels+2)]c(1:channels)[inopponent==F]}# A function which gets the cones that do not pertain to# opponency mechanism x.lowertriind<-which(lower.tri(matrix(NA, ncol=channels, nrow=channels))==T, arr.ind=T)# A function which gets the indices of a matrix lower triangle.calcdeltast<-function(stimulusa, stimulusb){catches<-(as.matrix(coneoutput[,3:(channels+2)][c(stimulusa, stimulusb),]))delta<-as.vector(log(catches[1,])-log(catches[2,]))opponent<-(outer(delta, delta, "-")^2)QFP<-as.vector((t(catches)%*%matrix(1, ncol=1, nrow=2))/2)QFP<-QFP*c(na.omit(as.numeric(as.character((heads[roww,][2])$b)), as.numeric(as.character((heads[roww,][3])$c)), as.numeric(as.character((heads[roww,][4])$d)), as.numeric(as.character((heads[roww,][5])$e))))QFP<-log(QFP*alpha)NoiseBT<-noisef(QFP, WFP, RDP)if(channels>2){noisecha<-t(matrix(unlist(lapply(1:dim(lowertriind)[1], FUN=otherchan)), nrow=channels-2))cube<-matrix(NoiseBT[noisecha], ncol=channels-2)ltrinoise<-(unlist(lapply(1:dim(lowertriind)[1], data=cube, FUN=prodrows)))^2noise<-matrix(NA, ncol=channels, nrow=channels)noise[lowertriind]<-ltrinoise}if(channels==2){noise[lowertriind]<-1}Vorobnumerator<-sum((noise*opponent)[lowertriind])Vorobdenominator<-sum(unlist(lapply(1:channels, y=c(NoiseBT), FUN=denom)))round(((Vorobnumerator/Vorobdenominator)^0.5), 5)}veccalcdeltast<-function(a, b) sapply(seq(along=a), function(i)calcdeltast(a[i],b[i]))if(allorsome=="SOME"){patchorg<-function(patno, measno){rep(patno, measno)}patchinbird<-unlist(lapply(c(1:as.numeric(Patcherer)), measno=numberperpatch, FUN=patchorg))newcone2<-patchinbird[coneoutput[,2]]Avornot<-rep(0, length(coneoutput[,1]))getavbirds<-function(x){length(grep(as.character(coneoutput[,1][x]), Averagebirds))}Avornot[(unlist(lapply(c(1:length(coneoutput[,1])), FUN=getavbirds))==1)]<-newcone2[(unlist(lapply(c(1:length(coneoutput[,1])), FUN=getavbirds))==1)]meandiff<-function(patchtype){plank<-(outer(which(Avornot==patchtype), which(newcone2==patchtype), FUN=veccalcdeltast))t(plank)%*%rep(1, length(plank[,1]))/length(plank[,1])}namesindex<-function(patchtype){as.character(coneoutput[,1][which(newcone2==patchtype)])}patchindex<-function(patchtype){as.character(coneoutput[,2][which(newcone2==patchtype)])}dataclean<-rbind(c("Exp.No", "filenumber", "Contrast"), cbind(unlist(lapply(c(1:as.numeric(Patcherer)), FUN=namesindex)),unlist(lapply(c(1:as.numeric(Patcherer)), FUN=patchindex)),unlist(lapply(c(1:as.numeric(Patcherer)), FUN=meandiff))))}if(allorsome=="ALL"){q<-outer(c(1:length(coneoutput[,1])), c(1:length(coneoutput[,1])), FUN="veccalcdeltast")dataclean<-cbind(c("", "Exp.No", as.character(as.character(coneoutput[,1]))), c("Exp.No", "filenumber", as.character(coneoutput[,2])), rbind(as.character(coneoutput[,1]), as.character(coneoutput[,2]), q))}	# Opens and attaches the file containing the cone outputswrite.table(dataclean, file=Contrastsfilepath, row.names=F, col.names=F, append=TRUE, sep = ",")cendrawasih<-data.frame(read.csv(Contrastsfilepath, sep=",", skip=7))attach(cendrawasih)# Opens and attaches output file.switch(menu(c("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPress 1 and then Return to see the Contrast data on the R console")), print(cendrawasih))# Gives the option of viewing the output file.headge<-read.csv(Contrastsfilepath, sep=",")switch(menu(c("Press 1 and then Return to see information concerning the data on the R console")), print(headge[1:6,]))